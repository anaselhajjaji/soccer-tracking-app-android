package anaware.soccer.tracker.backup

import anaware.soccer.tracker.data.BackupMatch
import anaware.soccer.tracker.data.Match
import anaware.soccer.tracker.data.Player
import anaware.soccer.tracker.data.SoccerAction
import anaware.soccer.tracker.data.Team
import android.content.Context
import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.auth.api.signin.GoogleSignInOptions
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.GoogleAuthProvider
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withContext

/**
 * Service for handling Firebase Authentication and Firestore backup/restore operations.
 * Data is scoped per authenticated user.
 */
class FirebaseService(private val context: Context) {

    private val auth: FirebaseAuth = FirebaseAuth.getInstance()
    private val firestore: FirebaseFirestore = FirebaseFirestore.getInstance()

    companion object {
        private const val COLLECTION_USERS = "users"
        const val RC_SIGN_IN = 9001

        /**
         * Generate a unique ID for a new action based on timestamp.
         */
        fun generateActionId(): Long {
            return System.currentTimeMillis()
        }

        /**
         * Generate a unique ID for a new player using UUID.
         */
        fun generatePlayerId(): String {
            return java.util.UUID.randomUUID().toString()
        }

        /**
         * Generate a unique ID for a new team using UUID.
         */
        fun generateTeamId(): String {
            return java.util.UUID.randomUUID().toString()
        }

        /**
         * Generate a unique ID for a new match using UUID.
         */
        fun generateMatchId(): String {
            return java.util.UUID.randomUUID().toString()
        }
    }

    /**
     * Get the currently signed-in user's email.
     */
    fun getCurrentUserEmail(): String? {
        return auth.currentUser?.email
    }

    /**
     * Check if a user is currently signed in.
     */
    fun isUserSignedIn(): Boolean {
        return auth.currentUser != null
    }

    /**
     * Get Google Sign-In options configured for Firebase.
     * Note: Requires default_web_client_id from google-services.json
     */
    @Suppress("DiscouragedApi")
    fun getGoogleSignInOptions(): GoogleSignInOptions {
        // Get the web client ID from the google-services.json generated resources
        // Using getIdentifier() is necessary here as the resource is dynamically generated by google-services.json
        // and not available in R class at compile time
        val webClientId = try {
            context.getString(
                context.resources.getIdentifier(
                    "default_web_client_id",
                    "string",
                    context.packageName
                )
            )
        } catch (e: Exception) {
            throw IllegalStateException(
                "default_web_client_id not found - ensure google-services.json is configured",
                e
            )
        }

        return GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
            .requestIdToken(webClientId)
            .requestEmail()
            .build()
    }

    /**
     * Sign in to Firebase with Google credentials.
     */
    suspend fun signInWithGoogle(idToken: String): Result<String> = withContext(Dispatchers.IO) {
        try {
            val credential = GoogleAuthProvider.getCredential(idToken, null)
            val result = auth.signInWithCredential(credential).await()
            val email = result.user?.email ?: return@withContext Result.failure(
                Exception("Failed to get user email")
            )
            Result.success(email)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Attempt silent sign-in with Google (no UI).
     * Returns the last signed-in account if available.
     */
    suspend fun silentSignIn(): Result<String> = withContext(Dispatchers.IO) {
        try {
            // Check if already signed in to Firebase
            val currentUser = auth.currentUser
            if (currentUser != null) {
                return@withContext Result.success(currentUser.email ?: "Unknown")
            }

            // Try to get last signed-in Google account
            val googleSignInClient = GoogleSignIn.getClient(context, getGoogleSignInOptions())
            val account = googleSignInClient.silentSignIn().await()
            val idToken = account?.idToken

            if (idToken != null) {
                // Sign in to Firebase with the token
                return@withContext signInWithGoogle(idToken)
            } else {
                Result.failure(Exception("No cached sign-in available"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Sign out the current user.
     */
    suspend fun signOut() = withContext(Dispatchers.IO) {
        try {
            // Sign out from Firebase
            auth.signOut()

            // Sign out from Google Sign-In
            val googleSignInClient = GoogleSignIn.getClient(context, getGoogleSignInOptions())
            googleSignInClient.signOut().await()
        } catch (e: Exception) {
            // Ignore sign-out errors
        }
    }

    /**
     * Add a new soccer action to Firestore.
     * Data is stored at: users/{userId}/actions/{actionId}
     */
    suspend fun addAction(action: SoccerAction): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            // Convert to BackupAction format for storage
            val backupAction = anaware.soccer.tracker.data.BackupAction.fromSoccerAction(action)

            // Store in Firestore at users/{userId}/actions/{actionId}
            firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("actions")
                .document(action.id.toString())
                .set(backupAction)
                .await()

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Delete a soccer action from Firestore.
     */
    suspend fun deleteAction(actionId: Long): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("actions")
                .document(actionId.toString())
                .delete()
                .await()

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Update an existing soccer action in Firestore.
     */
    suspend fun updateAction(action: SoccerAction): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            // Convert to BackupAction format for storage
            val backupAction = anaware.soccer.tracker.data.BackupAction.fromSoccerAction(action)

            // Update in Firestore at users/{userId}/actions/{actionId}
            firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("actions")
                .document(action.id.toString())
                .set(backupAction) // set() will create or update
                .await()

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Get all soccer actions from Firestore for the current user.
     */
    suspend fun getAllActions(): Result<List<SoccerAction>> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            val snapshot = firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("actions")
                .get()
                .await()

            val actions = snapshot.documents.mapNotNull { doc ->
                try {
                    val backupAction = doc.toObject(anaware.soccer.tracker.data.BackupAction::class.java)
                    val id = doc.id.toLongOrNull() ?: return@mapNotNull null
                    backupAction?.toSoccerAction(id)
                } catch (e: Exception) {
                    null
                }
            }

            Result.success(actions)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    // ========== Player Operations ==========

    /**
     * Add a new player to Firestore.
     * Data is stored at: users/{userId}/players/{playerId}
     */
    suspend fun addPlayer(player: Player): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            val backupPlayer = anaware.soccer.tracker.data.BackupPlayer.fromPlayer(player)

            firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("players")
                .document(player.id)
                .set(backupPlayer)
                .await()

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Update an existing player in Firestore.
     */
    suspend fun updatePlayer(player: Player): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            val backupPlayer = anaware.soccer.tracker.data.BackupPlayer.fromPlayer(player)

            firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("players")
                .document(player.id)
                .set(backupPlayer)
                .await()

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Delete a player from Firestore.
     */
    suspend fun deletePlayer(playerId: String): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("players")
                .document(playerId)
                .delete()
                .await()

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Get all players from Firestore for the current user.
     */
    suspend fun getAllPlayers(): Result<List<Player>> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            val snapshot = firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("players")
                .get()
                .await()

            val players = snapshot.documents.mapNotNull { doc ->
                try {
                    doc.toObject(anaware.soccer.tracker.data.BackupPlayer::class.java)?.toPlayer()
                } catch (e: Exception) {
                    null
                }
            }

            Result.success(players)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    // ========== Team Operations ==========

    /**
     * Add a new team to Firestore.
     * Data is stored at: users/{userId}/teams/{teamId}
     */
    suspend fun addTeam(team: Team): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            val backupTeam = anaware.soccer.tracker.data.BackupTeam.fromTeam(team)

            firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("teams")
                .document(team.id)
                .set(backupTeam)
                .await()

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Update an existing team in Firestore.
     */
    suspend fun updateTeam(team: Team): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            val backupTeam = anaware.soccer.tracker.data.BackupTeam.fromTeam(team)

            firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("teams")
                .document(team.id)
                .set(backupTeam)
                .await()

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Delete a team from Firestore.
     */
    suspend fun deleteTeam(teamId: String): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("teams")
                .document(teamId)
                .delete()
                .await()

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Get all teams from Firestore for the current user.
     */
    suspend fun getAllTeams(): Result<List<Team>> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            val snapshot = firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("teams")
                .get()
                .await()

            val teams = snapshot.documents.mapNotNull { doc ->
                try {
                    doc.toObject(anaware.soccer.tracker.data.BackupTeam::class.java)?.toTeam()
                } catch (e: Exception) {
                    null
                }
            }

            Result.success(teams)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    // ========== Migration Operations ==========

    /**
     * Update an action's player and team assignment.
     * Used for migrating legacy actions to new player/team system.
     */
    suspend fun updateActionPlayerTeam(
        actionId: Long,
        playerId: String,
        teamId: String
    ): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("actions")
                .document(actionId.toString())
                .update(
                    mapOf(
                        "playerId" to playerId,
                        "teamId" to teamId
                    )
                )
                .await()

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    // ==================== Match CRUD Operations ====================

    /**
     * Add a new match to Firestore.
     */
    suspend fun addMatch(match: Match): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            val backupMatch = BackupMatch.fromMatch(match)

            firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("matches")
                .document(match.id)
                .set(backupMatch)
                .await()

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Update an existing match in Firestore.
     */
    suspend fun updateMatch(match: Match): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            val backupMatch = BackupMatch.fromMatch(match)

            firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("matches")
                .document(match.id)
                .set(backupMatch)
                .await()

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Delete a match from Firestore.
     */
    suspend fun deleteMatch(matchId: String): Result<Unit> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("matches")
                .document(matchId)
                .delete()
                .await()

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Get all matches from Firestore.
     */
    suspend fun getAllMatches(): Result<List<Match>> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            val snapshot = firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("matches")
                .get()
                .await()

            val matches = snapshot.documents.mapNotNull { doc ->
                try {
                    doc.toObject(BackupMatch::class.java)?.toMatch()
                } catch (e: Exception) {
                    null
                }
            }

            Result.success(matches)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Get a match by ID from Firestore.
     */
    suspend fun getMatchById(matchId: String): Result<Match?> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            val doc = firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("matches")
                .document(matchId)
                .get()
                .await()

            val match = doc.toObject(BackupMatch::class.java)?.toMatch()
            Result.success(match)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Find or create a match based on date and teams.
     * Returns the match ID.
     */
    suspend fun findOrCreateMatch(
        date: String,
        playerTeamId: String,
        opponentTeamId: String,
        league: String = ""
    ): Result<String> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            // Query for existing match with same date + teams
            val snapshot = firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("matches")
                .whereEqualTo("date", date)
                .whereEqualTo("playerTeamId", playerTeamId)
                .whereEqualTo("opponentTeamId", opponentTeamId)
                .get()
                .await()

            if (!snapshot.isEmpty) {
                // Match exists, return its ID
                val matchId = snapshot.documents.first().id
                Result.success(matchId)
            } else {
                // Create new match
                val matchId = generateMatchId()
                val match = Match(
                    id = matchId,
                    date = date,
                    playerTeamId = playerTeamId,
                    opponentTeamId = opponentTeamId,
                    league = league,
                    playerScore = -1,
                    opponentScore = -1
                )

                addMatch(match).getOrThrow()
                Result.success(matchId)
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    /**
     * Find or create an opponent team from a team name.
     * Returns the team ID.
     */
    suspend fun findOrCreateOpponentTeam(opponentName: String): Result<String> = withContext(Dispatchers.IO) {
        try {
            val userId = auth.currentUser?.uid ?: return@withContext Result.failure(
                Exception("User not signed in")
            )

            // Query for existing team with same name
            val snapshot = firestore.collection(COLLECTION_USERS)
                .document(userId)
                .collection("teams")
                .whereEqualTo("name", opponentName)
                .get()
                .await()

            if (!snapshot.isEmpty) {
                // Team exists, return its ID
                val teamId = snapshot.documents.first().id
                Result.success(teamId)
            } else {
                // Create new team
                val teamId = generateTeamId()
                val team = Team(
                    id = teamId,
                    name = opponentName,
                    color = "#FF5722", // Default color for opponent teams (deep orange)
                    league = "",
                    season = ""
                )

                addTeam(team).getOrThrow()
                Result.success(teamId)
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
